import requests
import time
import argparse

print("""\033[35m

   *                                                               
 (  `        (                         *   )                       
 )\))(     ) )\(  (      ) (     (   ` )  /((  (     ) (  (    (   
((_)()\ ( /(((_)\))(  ( /( )(   ))\   ( )(_))( )\ ( /( )\))(  ))\  
(_()((_))(_))_((_)()\ )(_)|()\ /((_) (_(_()|()((_))(_)|(_))\ /((_) 
|  \/  ((_)_| |(()((_|(_)_ ((_|_))   |_   _|((_|_|(_)_ (()(_|_))   
| |\/| / _` | \ V  V / _` | '_/ -_)    | | | '_| / _` / _` |/ -_)  
|_|  |_\__,_|_|\_/\_/\__,_|_| \___|    |_| |_| |_\__,_\__, |\___|  
                                                      |___/        
                                                            
\033[m""")

def virustotal_ip(ip):
    time.sleep(1)
    ip_addr = ip
    print("\n\033[1;35mVirusTotal IP Lookup: {}\033[m\n".format(ip_addr))
    ip_vt = "https://www.virustotal.com/api/v3/ip_addresses/"+ip
    headers_vt = {
        "accept": "application/json",
        "x-apikey": ""
    }
    response_vt = requests.get(ip_vt, headers=headers_vt)
    if response_vt.status_code == 200:
        response_vt_return = response_vt.json()
        malicious = response_vt_return['data']['attributes']['last_analysis_stats']['malicious']
        suspicious = response_vt_return['data']['attributes']['last_analysis_stats']['suspicious']
        harmless = response_vt_return['data']['attributes']['last_analysis_stats']['harmless']
        undetected = response_vt_return['data']['attributes']['last_analysis_stats']['undetected']
        print(f"\033[1;31m[!] Maliciousness Index: {malicious}\033[m")
        print(f"\033[1;33m[!] Suspicion Index: {suspicious}\033[m")
        print(f"\033[1;32m[+] Harmlessness Index: {harmless}\033[m")
        print(f"\033[1;36m[+] Undetectability Index: {undetected}\033[m")

def virustotal_hash(hash):
    time.sleep(1)
    sample_hash = hash
    print("\n\033[1;35mArtifact Analysis: {}\033[m\n".format(sample_hash))
    hash_vt = "https://www.virustotal.com/api/v3/files/"+hash
    headers_vt = {
        "accept": "application/json",
        "x-apikey": ""
    }
    response_vt = requests.get(hash_vt, headers=headers_vt)
    if response_vt.status_code == 200:
        response_vt_return = response_vt.json()
        malicious = response_vt_return['data']['attributes']['last_analysis_stats']['malicious']
        suspicious = response_vt_return['data']['attributes']['last_analysis_stats']['suspicious']
        harmless = response_vt_return['data']['attributes']['last_analysis_stats']['harmless']
        undetected = response_vt_return['data']['attributes']['last_analysis_stats']['undetected']
        vt_threat_classification = response_vt_return['data']['attributes']['popular_threat_classification']['popular_threat_name'][0]['value']
        vt_threat_type = response_vt_return['data']['attributes']['popular_threat_classification']['popular_threat_name'][1]['value']
        vt_threat_tag = response_vt_return['data']['attributes']['popular_threat_classification']['suggested_threat_label']
        vt_imphash = response_vt_return['data']['attributes']['pe_info']['imphash']
        vt_pe_info_type = response_vt_return['data']['attributes']['type_description']
        vt_pe_info_names = response_vt_return['data']['attributes']['names']

        print("""\033[1;35m
              
Artifact General Information
              
             \033[m""")
        print(f"\t\033[1;32m[+] Artifact Type: {vt_pe_info_type}\033[m")
        for pe_names in vt_pe_info_names:
            print(f"\t\033[1;32m[+] Names Associated with the Artifact: {pe_names}\033[m")
        
        import_table = response_vt_return['data']['attributes']['pe_info']['import_list']
        for import_item in import_table:
            vt_import_DLL_table = import_item['library_name']
            vt_import_func_table = import_item['imported_functions']
            
            print(f"""\033[1;35m

Artifact Import Table Information

                  \033[m""")
            try:
                print(f"\t\033[1;36m[-] Imported Library: {vt_import_DLL_table} \033[m")
                print(f"\t\033[1;36m[-] Imported Functions from Library {vt_import_DLL_table}:\033[m\n")
                for import_table in vt_import_func_table:
                    print(f"\t\t\033[1;31m-{import_table}\033[m")
            except KeyError:
                print(f"\033[1;33m[!] There are no information of Import Table for this artifact. This a binary artifact?\033[m\n")
        
        print("""\033[1;35m

Artifact Section Information
        \033[m""")
        
        sections = response_vt_return['data']['attributes']['pe_info']['sections']
        try:
            for section in sections:
                vt_section_name = section['name']
                vt_section_entropy = section['entropy']
                vt_section_flags = section['flags']
                vt_section_md5 = section['md5']

                print(f"\n\t\033[1;36m[-] PE Sample Section: {vt_section_name}\033[m")
                if vt_section_entropy >= 6.5:
                    print(f"\t\033[1;31m[!] Section Entropy {vt_section_name}: {vt_section_entropy}\033[m")
                else:
                    print(f"\t\033[1;32m[+] Section Entropy {vt_section_name}: {vt_section_entropy}\033[m")
                if vt_section_flags == 'rx':
                    print(f"\t\033[1;31m[!] Section Flags {vt_section_name}: {vt_section_flags}\033[m")
                else:
                    print(f"\t\033[1;36m[+] Section Flags {vt_section_name}: {vt_section_flags}\033[m")
                print(f"\t\033[1;36m[-] Section MD5 {vt_section_name}: {vt_section_md5}\033[m")
        except KeyError:
            print(f"\033[1;33m[!] There are no information of Sections for this artifact. This a binary artifact?\033[m\n")
            

        print("""\033[1;35m
              
Artifact Verdict Information
              
              \033[m""")
        
        print(f"\t\033[1;31m[!] Maliciousness Index: {malicious}\033[m")
        print(f"\t\033[1;33m[!] Suspicion Index: {suspicious}\033[m")
        print(f"\t\033[1;32m[+] Harmlessness Index: {harmless}\033[m")
        print(f"\t\033[1;36m[-] Undetectability Index: {undetected}\033[m")
        
        print("""\033[1;35m
              
Artifact Classification Information
              
              \033[m""")
        try:
            print(f"\t\033[1;31m[!] VT Classification: {vt_threat_classification}\033[m")
            print(f"\t\033[1;31m[!] Threat Type: {vt_threat_type}\033[m")
            print(f"\t\033[1;31m[!] Threat Tag: {vt_threat_tag}\033[m")
            print(f"\t\033[1;31m[!] Imphash: {vt_imphash}\033[m")
        except KeyError:
            print(f"\033[1;33m[!] There are no public recurrences of Threat Classification for this artifact\033[m\n")
        
        

        print("""\033[1;35m
              
Artifact Public Intelligence Information - Yara Rules
              
              \033[m""")
        try:
            vt_yara_matches_public = response_vt_return['data']['attributes']['crowdsourced_yara_results']
            for yara in vt_yara_matches_public:
                vt_yara_name = yara['rule_name']
                vt_yara_author = yara['author']
                vt_yara_source = yara['source']
                print(f"\t\033[1;31m[!] Yara Rule Matches {vt_yara_name} \033[m")
                print(f"\t\033[1;36m[!] Yara Rule Author: {vt_yara_author} \033[m")
                print(f"\t\033[1;36m[!] Yara Rule Source: {vt_yara_source} \033[m\n")
        except KeyError:
            print(f"\033[1;33m[!] There are no public recurrences of Yara rules for this artifact\033[m\n")

        print("""\033[1;35m
              
Artifact Public Intelligence Information - Sigma Rules
              
              \033[m""")
        try:
            vt_sigma_info_public = response_vt_return['data']['attributes']['sigma_analysis_results']
            for sigma in vt_sigma_info_public:
                vt_sigma_name = sigma['rule_title']
                vt_sigma_description = sigma['rule_description']
                vt_sigma_source = sigma['rule_source']
                vt_sigma_author = sigma['rule_author']
            vt_sigma_matches = response_vt_return['data']['attributes']['sigma_analysis_results']
            for context in vt_sigma_matches:
                match_context = context['match_context']
                for match in match_context:
                    match_cond = match['values']
            
                print(f"\n\t\033[1;36m[!] Sigma Rule Name: {vt_sigma_name}\033[m")
                print(f"\t\033[1;36m[!] Sigma Rule Description {vt_sigma_name}: {vt_sigma_description}\033[m")
                print(f"\t\033[1;36m[!] Sigma Rule Source {vt_sigma_name}: {vt_sigma_source}\033[m")
                print(f"\t\033[1;36m[!] Public Author of Sigma Rule {vt_sigma_name}: {vt_sigma_author}\033[m")
                print(f"\t\033[1;33m[!] Sigma Rule Match Conditions {vt_sigma_name}:\033[m\n")
                for key, value in match_cond.items():
                    print(f"\t\t\033[1;31m{key}:{value}\033[m")
                print("")
        except KeyError:
            print(f"\033[1;33m[!] There are no public recurrences of Sigma rules for this artifact\033[m\n")
        

def main():
    parser = argparse.ArgumentParser(description="Malware Triage Script via VirusTotal")
    
    parser.add_argument("-H", dest="hash_value", help="SHA1, SHA256, or MD5 hash of the Sample")
    parser.add_argument("-I", dest="ip_address", help="IP Address")
    
    group = parser.add_mutually_exclusive_group(required=True)
    group.add_argument("-vtf", action="store_true", help="Perform hash recurrence analysis on VirusTotal")
    group.add_argument("-vti", action="store_true", help="Perform an IP address recurrence analysis on VirusTotal")

    args = parser.parse_args()

    if args.vtf and args.hash_value:
        virustotal_hash(args.hash_value)
    elif args.vti and args.ip_address:
        virustotal_ip(args.ip_address)
    else:
        print("Invalid arguments. Make sure to provide the correct arguments.")

if __name__ == "__main__":
    main()
